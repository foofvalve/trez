"use strict";

let downloadToBuffer = (() => {
  var _ref2 = _asyncToGenerator(function* (path) {
    try {
      const res = yield get(path);
      if (res.statusCode >= 400) {
        fatal(`Server responded with code ${res.statusCode} while fetching "${path}".`);
      }
      return res.body;
    } catch (e) {
      fatal(`Failed to resolve URL "${path}".`);
    }
  });

  return function downloadToBuffer(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

let bundleToStream = (() => {
  var _ref3 = _asyncToGenerator(function* (path) {
    const temppath = yield createBundle(path);
    return createReadStream(temppath);
  });

  return function bundleToStream(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { createBundle } = require("./bundle");
const { createReadStream } = require("fs");
const { fatal } = require("./util/log");
const request = require("request");
const { parse: parseUrl } = require("url");
const { safeStat } = require("./util/fs");

function get(path) {
  return new Promise((resolve, reject) => {
    request(path, { encoding: null }, (err, res) => {
      if (err) reject(err);else resolve(res);
    });
  });
}

module.exports = (() => {
  var _ref = _asyncToGenerator(function* (path) {
    if (path === "@") {
      const stream = process.stdin;
      stream.path = "data.bin";
      return stream;
    }
    const stats = yield safeStat(path);
    if (stats) {
      if (stats.isDirectory(path)) {
        return bundleToStream(path);
      }
      return createReadStream(path);
    }
    const { protocol } = parseUrl(path);
    if (protocol) {
      return yield downloadToBuffer(path);
    }
    fatal(`No such file or directory: "${path}".`);
  });

  function resolveToStream(_x) {
    return _ref.apply(this, arguments);
  }

  return resolveToStream;
})();