/*eslint-disable no-console */
"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let foxxWizard = (() => {
  var _ref3 = _asyncToGenerator(function* (_ref2) {
    let { cwd } = _ref2,
        options = _objectWithoutProperties(_ref2, ["cwd"]);

    const answers = yield prompt([{
      name: "name",
      message: "Name",
      default: options.name
    }, {
      name: "version",
      message: "Version",
      default: options.version,
      validate: function (answer) {
        return Boolean(validVersion(answer)) || `Not a valid semver version: "${red(answer)}"`;
      }
    }, {
      name: "license",
      message: `License ${gray("(ex: Apache-2.0)")}`,
      default: options.license,
      filter: function (answer) {
        return licenseMap[answer.toUpperCase()] || answer;
      },
      validate: function (answer) {
        if (!answer) return true;
        const licenseKey = answer.toUpperCase();
        if (hasOwnProperty.call(licenseMap, licenseKey)) return true;
        const matches = Object.keys(licenseMap).filter(function (key) {
          return key.includes(licenseKey);
        }).sort().map(function (key) {
          return green(licenseMap[key]);
        });
        if (matches.length) {
          return `Not a valid SPDX license: "${red(answer)}". Did you mean ${matches.length > 1 ? `${matches.slice(0, -1).join(", ")} or ${matches[matches.length - 1]}` : matches[0]}?`;
        }
        return `Not a valid SPDX license: "${red(answer)}". Leave empty for "all rights reserved".`;
      }
    }, {
      name: "authorEmail",
      message: `Author e-mail ${gray("(ex: jd@example.com)")}`,
      default: options.authorEmail
    }, {
      name: "authorName",
      message: `Author name ${gray("(ex: John Doe)")}`,
      default: function (answers) {
        return options.authorName || (answers.authorEmail ? answers.authorEmail.split("@")[0] : options.authorName);
      }
    }, {
      name: "engineVersion",
      message: "ArangoDB version",
      default: options.engineVersion,
      validate: function (answer) {
        return Boolean(validRange(answer)) || `Not a valid semver range: "${red(answer)}"`;
      }
    }, {
      name: "description",
      message: "Description",
      default: options.description
    }, {
      name: "documentCollections",
      message: `Document collection names ${gray("(ex: foo, bar)")}`,
      default: options.documentCollections,
      filter: function (answer) {
        const names = uniq(answer.split(",").map(function (name) {
          return name.replace(/(^\s+|\s+$)/, "");
        }).filter(Boolean));
        return names.length ? names : "";
      },
      validate: function (answer) {
        if (!answer) return true;
        const bad = answer.filter(function (name) {
          return !/^[_a-z][_a-z0-9]+$/i.test(name);
        }).map(function (name) {
          return `"${red(name)}"`;
        });
        if (bad.length === 1) {
          return `The name ${bad[0]} is not a valid collection name.`;
        }
        if (bad.length) {
          return `The names ${bad.slice(0, -1).join(", ")} and ${bad[bad.length - 1]} are not valid collection names.`;
        }
        return true;
      }
    }, {
      name: "edgeCollections",
      message: `Edge collection names ${gray("(ex: qux, baz)")}`,
      default: options.edgeCollections,
      filter: function (answer) {
        const names = uniq(answer.split(",").map(function (name) {
          return name.replace(/(^\s+|\s+$)/, "");
        }).filter(Boolean));
        return names.length ? names : "";
      },
      validate: function (answer, answers) {
        if (!answer || !answers.documentCollections) return true;
        const bad = answer.filter(function (name) {
          return !/^[_a-z][_a-z0-9]+$/i.test(name);
        }).map(function (name) {
          return `"${red(name)}"`;
        });
        if (bad.length === 1) {
          return `The name ${bad[0]} is not a valid collection name.`;
        }
        if (bad.length) {
          return `The names ${bad.slice(0, -1).join(", ")} and ${bad[bad.length - 1]} are not valid collection names.`;
        }
        const dupes = answer.filter(function (name) {
          return answers.documentCollections.includes(name);
        }).map(function (name) {
          return `"${red(name)}"`;
        });
        if (dupes.length === 1) {
          return `The collection ${dupes[0]} is already a document collection.`;
        }
        if (dupes.length) {
          return `The collections ${dupes.slice(0, -1).join(", ")} and ${dupes[dupes.length - 1]} are already document collections.`;
        }
        return true;
      }
    }, {
      name: "generateCrudRoutes",
      message: "Generate CRUD routes for collections",
      type: "confirm",
      default: false,
      when: function (answers) {
        return answers.documentCollections || answers.edgeCollections;
      }
    }]);
    console.log();
    const confirm = yield prompt([{
      name: "ok",
      message: "Is this information correct?",
      type: "confirm",
      default: true
    }, {
      name: "retry",
      message: "Try again?",
      when: function (answers) {
        return !answers.ok;
      },
      type: "confirm",
      default: false
    }]);
    console.log();
    if (confirm.retry) {
      return yield foxxWizard(_extends({}, answers, { cwd }));
    }
    if (!confirm.ok) throw new Error("Aborted.");
    if (!answers.documentCollections) answers.documentCollections = [];
    if (!answers.edgeCollections) answers.edgeCollections = [];
    return answers;
  });

  return function foxxWizard(_x2) {
    return _ref3.apply(this, arguments);
  };
})();

let configWizard = (() => {
  var _ref4 = _asyncToGenerator(function* (configs = {}) {
    console.log();
    const _ref5 = yield prompt([{
      name: "name",
      message: "Name",
      filter: function (answer) {
        return answer.replace(/(^\s+|\s+$)/g, "").replace(/\s+/g, "_");
      },
      validate: function (answer) {
        return answer && hasOwnProperty.call(configs, answer) ? `An option with the name "${red(answer)}" already exists.` : true;
      }
    }, {
      name: "description",
      message: "Description",
      when: function (answers) {
        return Boolean(answers.name);
      }
    }, {
      name: "type",
      message: "Type",
      when: function (answers) {
        return Boolean(answers.name);
      },
      type: "rawlist",
      choices: [{ value: "boolean", name: "Boolean" }, { value: "string", name: "String" }, { value: "password", name: "Password (masked)" }, { value: "number", name: "Number (decimal)" }, { value: "integer", name: "Number (integer)" }, { value: "json", name: "JSON expression" }]
    }, {
      name: "default",
      message: "Default value (JSON)",
      when: function (answers) {
        return Boolean(answers.name);
      },
      validate: function (answer) {
        try {
          if (answer) JSON.parse(answer);
        } catch (e) {
          return `Not a valid JSON expression: "${red(answer)}". Error: ${red(e.message)}\nDid you mean ${green(JSON.stringify(answer))}?`;
        }
        return true;
      }
    }, {
      name: "required",
      message: "Required?",
      when: function (answers) {
        return Boolean(answers.name) && !answers.default;
      },
      type: "confirm",
      default: true
    }]),
          { name } = _ref5,
          config = _objectWithoutProperties(_ref5, ["name"]);
    if (!name) return configs;
    if (!config.required) config.required = false;
    if (!config.description) delete config.description;
    if (!config.default) delete config.default;
    configs[name] = config;
    return yield configWizard(configs);
  });

  return function configWizard() {
    return _ref4.apply(this, arguments);
  };
})();

let depsWizard = (() => {
  var _ref6 = _asyncToGenerator(function* (deps = {}) {
    console.log();
    const _ref7 = yield prompt([{
      name: "alias",
      message: "Local alias",
      filter: function (answer) {
        return answer.replace(/(^\s+|\s+$)/g, "").replace(/\s+/g, "_");
      },
      validate: function (answer) {
        return answer && hasOwnProperty.call(deps, answer) ? `A dependency with the alias "${red(answer)}" already exists.` : true;
      }
    }, {
      name: "name",
      message: `Dependency name ${gray("(ex: @foxx/sessions)")}`,
      when: function (answers) {
        return Boolean(answers.alias);
      },
      default: "*",
      validate: function (answer) {
        if (!answer) return "Dependency name can not be empty.";
        if (answer.includes(":")) return "Dependency name must not contain colon.";
        return true;
      }
    }, {
      name: "version",
      message: `Dependency version range ${gray("(ex: ^1.0.0)")}`,
      when: function (answers) {
        return Boolean(answers.alias);
      },
      default: "*",
      validate: function (answer) {
        return answer === "*" || Boolean(validRange(answer)) || `Not a valid semver range: "${red(answer)}"`;
      }
    }, {
      name: "description",
      message: "Description",
      when: function (answers) {
        return Boolean(answers.alias);
      }
    }, {
      name: "required",
      message: "Required?",
      when: function (answers) {
        return Boolean(answers.alias);
      },
      type: "confirm",
      default: true
    }, {
      name: "multiple",
      message: "Allow multiple?",
      when: function (answers) {
        return Boolean(answers.alias);
      },
      type: "confirm",
      default: false
    }]),
          { alias } = _ref7,
          dep = _objectWithoutProperties(_ref7, ["alias"]);
    if (!alias) return deps;
    if (!dep.required) dep.required = false;
    if (!dep.multiple) dep.multiple = false;
    if (!dep.description) delete dep.description;
    deps[alias] = dep;
    return yield depsWizard(deps);
  });

  return function depsWizard() {
    return _ref6.apply(this, arguments);
  };
})();

let providedWizard = (() => {
  var _ref8 = _asyncToGenerator(function* (provided = {}) {
    console.log();
    const { name, version } = yield prompt([{
      name: "name",
      message: `Dependency name ${gray("(ex: @foxx/sessions)")}`,
      validate: function (answer) {
        if (!answer) return true;
        if (hasOwnProperty.call(provided, answer)) {
          return `The service already provides "${red(answer)}".`;
        }
        if (answer.includes(":")) {
          return "Dependency name must not contain colon.";
        }
        return true;
      }
    }, {
      name: "version",
      message: `Dependency version ${gray("(ex: 1.0.0)")}`,
      when: function (answers) {
        return Boolean(answers.name);
      },
      validate: function (answer) {
        return Boolean(validVersion(answer)) || `Not a valid semver version: "${red(answer)}"`;
      }
    }]);
    if (!name) return provided;
    provided[name] = version;
    return yield providedWizard(provided);
  });

  return function providedWizard() {
    return _ref8.apply(this, arguments);
  };
})();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { red, gray, green } = require("chalk");
const { prompt } = require("inquirer");
const { valid: validVersion, validRange } = require("semver");

const licenses = require("spdx-license-list");
const { uniq } = require("../util/array");

const licenseMap = Object.create(null);
for (const key of Object.keys(licenses)) {
  licenseMap[key.toUpperCase()] = key;
}

module.exports = (() => {
  var _ref = _asyncToGenerator(function* (options) {
    const answers = yield foxxWizard(options);
    answers.configuration = undefined;
    answers.dependencies = undefined;
    answers.provides = undefined;

    const { defineConfiguration } = yield prompt([{
      name: "defineConfiguration",
      message: "Define configuration options?",
      type: "confirm",
      default: false
    }]);

    if (defineConfiguration) {
      console.log();
      console.log("Leave name empty to stop adding configuration options.");
      const config = yield configWizard();
      if (Object.keys(config).length) {
        answers.configuration = config;
      }
      console.log();
    }

    const { defineDependencies } = yield prompt([{
      name: "defineDependencies",
      message: "Define Foxx dependencies used by this service?",
      type: "confirm",
      default: false
    }]);

    if (defineDependencies) {
      console.log();
      console.log("Leave local alias empty to stop adding dependencies.");
      const deps = yield depsWizard();
      if (Object.keys(deps).length) {
        answers.dependencies = deps;
      }
      console.log();
    }

    const { defineProvided } = yield prompt([{
      name: "defineProvided",
      message: "Define Foxx dependencies provided by this service?",
      type: "confirm",
      default: false
    }]);

    if (defineProvided) {
      console.log();
      console.log("Leave name empty to stop adding provided dependencies.");
      const provided = yield providedWizard();
      if (Object.keys(provided).length) {
        answers.provides = provided;
      }
      console.log();
    }

    return answers;
  });

  function wizard(_x) {
    return _ref.apply(this, arguments);
  }

  return wizard;
})();