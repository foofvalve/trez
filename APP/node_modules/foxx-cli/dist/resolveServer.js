"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let resolve = (() => {
  var _ref = _asyncToGenerator(function* (endpointOrName = "default") {
    if (endpointOrName.match(/^\/\//)) {
      return { url: `http:${endpointOrName}` };
    }
    if (endpointOrName.match(/^(unix|(https?|tcp|ssl|tls)(\+unix)?):\/\//)) {
      return { url: endpointOrName };
    }
    const ini = yield loadIni();
    if (ini.server[endpointOrName]) {
      return _extends({}, ini.server[endpointOrName], {
        name: endpointOrName
      });
    }
    if (endpointOrName === "default") {
      return { name: endpointOrName };
    }
    return null;
  });

  return function resolve() {
    return _ref.apply(this, arguments);
  };
})();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { bold, white } = require("chalk");
const { fatal } = require("./util/log");
const { load: loadIni } = require("./ini");
const { prompt } = require("inquirer");
const { unsplat } = require("./util/array");
const { readFile } = require("./util/fs");
const { parse: parseUrl } = require("url");

module.exports = (() => {
  var _ref2 = _asyncToGenerator(function* (argv) {
    if (argv.password && argv.token) {
      fatal(`Can not use both ${bold("password")} and ${bold("token")} as authentication for the same server.`);
    }
    if (argv.passwordFile && argv.token) {
      fatal(`Can not use both ${bold("passwordFile")} and ${bold("token")} as authentication for the same server.`);
    }
    if (argv.passwordFile && argv.password) {
      fatal(`Can not use both ${bold("passwordFile")} and ${bold("password")} as authentication for the same server.`);
    }
    if (argv.username && argv.token) {
      fatal(`Can not use both ${bold("username")} and ${bold("token")} as authentication for the same server.`);
    }
    const server = yield resolve(unsplat(argv.server));
    if (!server) {
      fatal(`Not a valid server: "${white(argv.server)}".`);
    }
    if (server.url === undefined) {
      server.url = "http://localhost:8529";
    }
    if (argv.database) {
      server.database = unsplat(argv.database);
    } else if (server.database === undefined) {
      server.database = "_system";
    }
    if (argv.username) {
      delete server.token;
      server.username = unsplat(argv.username);
      server.password = "";
    }
    if (argv.passwordFile) {
      delete server.token;
      try {
        server.password = yield readFile(argv.passwordFile, "utf-8");
      } catch (e) {
        fatal(`Error reading password file "${white(argv.passwordFile)}".`);
      }
    }
    if (argv.password) {
      delete server.token;
      const { password } = yield prompt([{
        message: "Password",
        name: "password",
        type: "password"
      }]);
      server.password = password;
    }
    if (argv.token) {
      delete server.username;
      delete server.password;
      const { token } = yield prompt([{
        message: "Token",
        name: "token",
        type: "password",
        validate: Boolean
      }]);
      server.token = token;
    }
    if (server.token === undefined && !parseUrl(server.url).auth) {
      if (server.username === undefined) {
        server.username = "root";
      }
      if (server.password === undefined) {
        server.password = "";
      }
    }
    if (server.password) {
      server.password = server.password.replace(/\r|\n/g, "");
    }
    return server;
  });

  function resolveServer(_x) {
    return _ref2.apply(this, arguments);
  }

  return resolveServer;
})();