"use strict";

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { exists, readFile, writeFile } = require("./util/fs");

const { Minimatch } = require("minimatch");

const defaults = [".git/", ".svn/", ".hg/", "*.swp", ".DS_Store"];

exports.load = (() => {
  var _ref = _asyncToGenerator(function* (file) {
    let lines = defaults;
    if (yield exists(file)) {
      const text = yield readFile(file, "utf-8");
      lines = text.replace(/\r/g, "").split(/\n+/g);
    }
    return exports.buildMatcher(lines);
  });

  function load(_x) {
    return _ref.apply(this, arguments);
  }

  return load;
})();

exports.buildMatcher = function buildMatcher(lines) {
  const blacklist = [];
  const whitelist = [];
  for (const line of lines) {
    let list = blacklist;
    let pattern = line.trim();
    if (pattern.startsWith("!")) {
      list = whitelist;
      pattern = pattern.slice(1);
    }
    if (!pattern) continue;
    if (pattern.endsWith("/")) pattern += "**";
    if (!pattern.startsWith("/")) pattern = "**/" + pattern;else pattern = pattern.slice(1);
    list.push(new Minimatch(pattern, { dot: true, nonegate: true }));
  }
  return path => whitelist.every(matcher => !matcher.match(path)) && blacklist.some(matcher => matcher.match(path));
};

exports.save = (() => {
  var _ref2 = _asyncToGenerator(function* (file, values, overwrite) {
    const patterns = new Set(values);
    if (!overwrite) {
      if (yield exists(file)) {
        const text = yield readFile(file, "utf-8");
        for (const line of text.split(/\n|\r/g)) {
          if (!line) continue;
          patterns.add(line);
        }
      } else {
        for (const line of defaults) {
          patterns.add(line);
        }
      }
    }
    const lines = Array.from(patterns.values());
    yield writeFile(file, lines.join("\n") + "\n");
  });

  function save(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  }

  return save;
})();