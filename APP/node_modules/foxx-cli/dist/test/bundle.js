/* global describe, it, beforeEach */
"use strict";

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const path = require("path");
const foxx = require("./util");
const expect = require("chai").expect;
const os = require("os");
const fs = require("fs");

const basePath = path.resolve(__dirname, "..", "..", "fixtures");
const tmpFile = path.resolve(os.tmpdir(), "minimal-working-service.zip");

describe("Foxx service bundle", () => {
  beforeEach(_asyncToGenerator(function* () {
    if (fs.existsSync(tmpFile)) {
      try {
        fs.unlinkSync(tmpFile);
      } catch (e) {
        // noop
      }
    }
  }));

  it("should output bundle per default", _asyncToGenerator(function* () {
    const output = yield foxx(`bundle ${path.resolve(basePath, "minimal-working-service")}`);
    expect(output).to.match(/^PK\u0003\u0004/);
  }));

  it("via alias should output bundle per default", _asyncToGenerator(function* () {
    const output = yield foxx(`zip ${path.resolve(basePath, "minimal-working-service")}`);
    expect(output).to.match(/^PK\u0003\u0004/);
  }));

  it("should output bundle with option stdout", _asyncToGenerator(function* () {
    const output = yield foxx(`bundle --stdout ${path.resolve(basePath, "minimal-working-service")}`);
    expect(output).to.match(/^PK\u0003\u0004/);
  }));

  it("should output bundle with alias of option stdout", _asyncToGenerator(function* () {
    const output = yield foxx(`bundle -O ${path.resolve(basePath, "minimal-working-service")}`);
    expect(output).to.match(/^PK\u0003\u0004/);
  }));

  it("should write bundle to outfile", _asyncToGenerator(function* () {
    const output = yield foxx(`bundle --outfile ${tmpFile} ${path.resolve(basePath, "minimal-working-service")}`);
    expect(output).to.equal("");
    expect(fs.existsSync(tmpFile)).to.equal(true);
    expect(fs.readFileSync(tmpFile, "utf-8")).to.match(/^PK\u0003\u0004/);
  }));

  it("via alias should write bundle to outfile", _asyncToGenerator(function* () {
    const output = yield foxx(`bundle -o ${tmpFile} ${path.resolve(basePath, "minimal-working-service")}`);
    expect(output).to.equal("");
    expect(fs.existsSync(tmpFile)).to.equal(true);
    expect(fs.readFileSync(tmpFile, "utf-8")).to.match(/^PK\u0003\u0004/);
  }));

  it("should not overwrite outfile per default", _asyncToGenerator(function* () {
    fs.writeFileSync(tmpFile, "no");
    try {
      yield foxx(`bundle --outfile ${tmpFile} ${path.resolve(basePath, "minimal-working-service")}`);
    } catch (e) {
      expect(fs.existsSync(tmpFile)).to.equal(true);
      expect(fs.readFileSync(tmpFile, "utf-8")).to.equal("no");
      return;
    }
    expect.fail();
  }));

  it("should overwrite outfile when forced", _asyncToGenerator(function* () {
    fs.writeFileSync(tmpFile, "");
    const output = yield foxx(`bundle --outfile ${tmpFile} --force ${path.resolve(basePath, "minimal-working-service")}`);
    expect(output).to.equal("");
    expect(fs.existsSync(tmpFile)).to.equal(true);
    expect(fs.readFileSync(tmpFile, "utf-8")).to.match(/^PK\u0003\u0004/);
  }));

  it("should overwrite outfile when forced via alias", _asyncToGenerator(function* () {
    fs.writeFileSync(tmpFile, "");
    const output = yield foxx(`bundle -o ${tmpFile} -f ${path.resolve(basePath, "minimal-working-service")}`);
    expect(output).to.equal("");
    expect(fs.existsSync(tmpFile)).to.equal(true);
    expect(fs.readFileSync(tmpFile, "utf-8")).to.match(/^PK\u0003\u0004/);
  }));

  it("should refuse when missing manifest", _asyncToGenerator(function* () {
    try {
      yield foxx(`bundle ${path.resolve(basePath, "sloppy-service")}`);
    } catch (e) {
      return;
    }
    expect.fail();
  }));

  it("should refuse when missing manifest even if forced", _asyncToGenerator(function* () {
    try {
      yield foxx(`bundle -f ${path.resolve(basePath, "sloppy-service")}`);
    } catch (e) {
      return;
    }
    expect.fail();
  }));

  it("should bundle even if missing manifest when sloppy", _asyncToGenerator(function* () {
    const output = yield foxx(`bundle --sloppy ${path.resolve(basePath, "sloppy-service")}`);
    expect(output).to.match(/^PK\u0003\u0004/);
  }));

  it("should not bundle if source does not exist", _asyncToGenerator(function* () {
    try {
      yield foxx(`bundle ${path.resolve(basePath, "no-such-service")}`);
    } catch (e) {
      return;
    }
    expect.fail();
  }));

  it("should output bundle of cwd", _asyncToGenerator(function* () {
    const output = yield foxx("bundle", false, {
      cwd: path.resolve(basePath, "minimal-working-service")
    });
    expect(output).to.match(/^PK\u0003\u0004/);
  }));
});