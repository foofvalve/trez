"use strict";

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { createReadStream, createWriteStream } = require("fs");
const { resolve: resolvePath } = require("path");

const archiver = require("archiver");
const { createWriteStream: createTempStream } = require("temp");
const temp = require("temp");
const { version } = require("../../package.json");
const fs = require("./fs");

const comment = `Created with foxx-cli v${version} (https://foxx.arangodb.com)`;

function append(zipstream, basepath, name) {
  return new Promise((resolve, reject) => {
    const stream = createReadStream(resolvePath(basepath, name));
    stream.on("error", e => reject(e));
    stream.on("close", () => resolve());
    zipstream.append(stream, { name });
  });
}

exports.zip = function zip(basepath, files, dest) {
  return new Promise((() => {
    var _ref = _asyncToGenerator(function* (resolve, reject) {
      let filename, filestream;
      if (typeof dest === "string") {
        filename = dest;
        filestream = createWriteStream(dest);
      } else if (dest) {
        filestream = dest;
        filename = dest.path;
      } else {
        filestream = createTempStream({ suffix: ".zip" });
        filename = filestream.path;
      }
      filestream.on("close", function () {
        return resolve(filename);
      });
      filestream.on("error", function (e) {
        return reject(e);
      });
      const zipstream = archiver("zip", { comment });
      zipstream.on("error", function (e) {
        return reject(e);
      });
      zipstream.pipe(filestream);
      for (const name of files) {
        yield append(zipstream, basepath, name);
      }
      zipstream.finalize();
    });

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  })());
};

exports.extractBuffer = (() => {
  var _ref2 = _asyncToGenerator(function* (buf, ...args) {
    const tmpfile = temp.path({ suffix: ".zip" });
    try {
      yield fs.writeFile(tmpfile, buf);
      yield fs.extract(tmpfile, ...args);
    } finally {
      yield fs.unlink(tmpfile);
    }
  });

  function extractBuffer(_x3) {
    return _ref2.apply(this, arguments);
  }

  return extractBuffer;
})();