"use strict";

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const extractZip = require("extract-zip");
const fs = require("fs");
const promisify = require("util.promisify");
const path = require("path");

const promisify2 = fn => (...args) => new Promise((resolve, reject) => {
  try {
    fn(...args, result => {
      resolve(result);
    });
  } catch (e) {
    reject(e);
  }
});

exports.extract = promisify(extractZip);
exports.exists = promisify2(fs.exists);
exports.mkdir = promisify(fs.mkdir);
exports.readdir = promisify(fs.readdir);
exports.readFile = promisify(fs.readFile);
exports.stat = promisify(fs.stat);
exports.unlink = promisify(fs.unlink);
exports.writeFile = promisify(fs.writeFile);
exports.realpath = promisify(fs.realpath);

exports.safeStat = (() => {
  var _ref = _asyncToGenerator(function* (path) {
    try {
      const stats = yield exports.stat(path);
      return stats;
    } catch (e) {
      return null;
    }
  });

  function safeStat(_x) {
    return _ref.apply(this, arguments);
  }

  return safeStat;
})();

exports.walk = (() => {
  var _ref2 = _asyncToGenerator(function* (basepath, shouldIgnore) {
    const followed = [yield exports.realpath(basepath)];
    const dirs = [basepath];
    const files = [];
    for (const dirpath of dirs) {
      const names = yield exports.readdir(dirpath);
      yield Promise.all(names.map((() => {
        var _ref3 = _asyncToGenerator(function* (name) {
          const abspath = path.join(dirpath, name);
          const stats = yield exports.safeStat(abspath);
          if (stats.isDirectory()) {
            const realpath = yield exports.realpath(abspath);
            if (realpath !== abspath) {
              if (followed.includes(realpath)) return;
              followed.push(realpath);
            }
            dirs.push(abspath);
          } else if (stats.isFile()) {
            const relpath = path.relative(basepath, abspath);
            if (shouldIgnore && shouldIgnore(relpath)) return;
            files.push(relpath);
          }
        });

        return function (_x4) {
          return _ref3.apply(this, arguments);
        };
      })()));
    }
    return files;
  });

  function walk(_x2, _x3) {
    return _ref2.apply(this, arguments);
  }

  return walk;
})();